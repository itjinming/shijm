# shijm

## 同步（sync）
###1.同步要解决的问题
1. 是否需要生成主键  

	2. 表是否有可能更改   
		2.1 如 transactionlog（交易明细表）,表中记录不会改变，只会添加数据  
		2.2 如 member（会员表） ，表中记录有可能更改，通过 modify 的时间来确定哪条数据进行了更改。  
	
	3. 表是否需要全表同步（有些小表没有时标信息，主键并不是递增的情况）

	4. 由2和3衍生出四种同步方式：  
		1. 数据不可改，实时同步。（当前只有transactionlog一张表）  
		2. 数据不可改，修正同步。修正同步用于实时同步的修正 和 没有实时同步要求，但需要日常同步的表。  
			其中修正实时同步表的dashboard与实时同步采用的dashboard并不是同一个。  
			修正数据的sql需要和实时同步的dashboard相联系。  修正同步dashboard表需要在系统启动的时候先构建。保证同步的大闭环，数据不丢失。  
		3. 数据可修改。（包括大表和小表）  
		4. 全表同步。  
			记录是否可修改通过比较规则进行区分，如果有比较规则，则有更新的需求。
			
	5.  可解决表内异常情况
		5.1 边界值重复
			形如：[1,1,2,3,4,5,5]
			meta采用">=" & "<="
		5.2 不严格递增
			形如：[1,1,2,3,4,5,5| 4 ]
			解决每时每刻边界的不严格递增只能采用模糊区间的方式。中间值的不严格递增并不会导致数据的缺失。
			明确了不严格递增是由于系统忙，产生的阶段性阻塞，导致数据并不会严格递增。
			问题可以曲线解决。
			采用在系统不忙，甚至几乎不工作的时刻调用本系统，就可以在一定程度上保证边界值的不严格递增。
			
###2.设计思路
	设计原则：
		1. 数据不丢失。
		2. 不与生产系统建立长事务连接。
		3. 多种表情况分治。
		4. 处理模式尽可能复用。
		5. 保留框架的可拓展性。
		6. 各存储信息类高内聚。
		7. 某些需要服务的存储信息类，需要将信息与计算分离。
		8. 拒绝多重判断，只判断一次（主要应用在是否编码的抉择上）。
		
####2.1 meta编写规则
	1. 数据不可改，实时同步。  
		">=" & "<="  
	2. 数据不可改，修正同步。  
		">=" & "<="  
	3. 数据可修改。  
		">=" & "<="  
	4. 全表同步。  
		select all 
	设计思想：
			所有meta中都要保证等于条件的结合。
			在数据不可更改的情况下，有cacahe对插入过的数据进行缓存，多余的数据并不是问题。
			在数据可更改的情况下，每次都需要进行比较，多几次比较并没有过多地消耗性能。

####2.2 dashboard加载时机 
	1.dashboard使用
		如果dashboard中有，从dashboard（redis）中获取。  
		如果dashboard中没有，从dst中重构dashboard。
	2.dashboard加载时机
		1. 数据不可改，实时同步。  
			同步任务开启时，加载dashboard
		2. 数据不可改，修正同步。  
			在系统启动时，加载dashboard
		3. 数据可修改。  
			同步任务开启时，加载dashboard
		4. 全表同步。 
			不需要dashboard，为保证结构一致，在同步任务开启时，加载dashboard。
	设计思想：
		1.同步任务开启加载dashboard非常好理解。
		2.修正同步时采用的系统启动加载，是由于在第一次加载的时候，其他情况可以正常展开，
			但是此种dashboard需要形成闭环，如果没有了锚点，则无法自行构建，需要优先级高一些加载。

####2.3 获取数据		
	获取数据分为两种，一种为range，一种为selectAll。
	range:
		1. 数据不可改，实时同步。
			where 1=1 and field >= "dashboard~sync" and field <= "ddl & meta"		order by field Asc
		2. 数据不可改，修正同步。  
			where 1=1 and field >= "dashboard~review" and field <= "dashboard~sync" order by field Asc
		3. 数据可修改。
			where 1=1 and field >= "dashboard~sync" and field <= "ddl & meta" 		order by field Asc
	
	selectAll:
		4. 全表同步。
			where 1=1

####2.4 TableCache的设计思路及其使用
	1.总体设计思路：
		1. 从类型上分为KeyCache和RecordCache，分别对应主键缓存和全数据缓存。
		2. 从使用上分为srcCache和dstCache，将数据源和目标数据库解耦，方便拓展。
			当前为一个数据源对应一个目标数据库。
			可拓展为一个数据源，同步至多个目标数据库。
		3. 从抽象上，将多种情况统一，以设计原则为指导，确定减少长连接的使用。
			数据源获取数据后所有情况都放入到srcCache（类型为RecordCache）。
				将srcCache设计为同步任务默认成员变量，不通过xml定义。
	2. 具体细节设计
		1. TableCache抽象类设计。
			考虑到实时同步表，当前会使用两个dashboard，但是会使用一个dstcache。
			1. 顺序同步。由于同步的顺序性，cache需要有顺序。
			2. 查找需求。为了应对边界值重复插入问题，cache需要O(1)查找效率。需要使用Map。
				经过1和2，选用LinkedHashMap。
			
			3. 锁机制。由于有多任务使用同一个表的情况，需要设计表cache锁。
				参考redisLock设计思路，为 TableCache添加lock属性。
				但是此种情况并没有覆盖所有情况。如下：
					1. 实时同步表在修正同步前启动，对dstCache上锁，导致修正同步失败。
						解决方案：应有一种机制，保证修正同步在凌晨一定完成一次修正。
									当前假定通过外围任务调度机制支持解决。
					
					这是由于修正同步只能在系统不忙甚至每人使用的时候才能保证数据不丢失。
	
		2.keyCache的缓存失效时间定义问题。
			有两种失效时间定义方式。
			1. 按记录时间开始计算。
			2. 按系统执行时间计算。
			
			考虑到后期有可能并不是所有表都是以时间为同步参照（以Number类型为参照），为了更好地兼容，本部分选择2.
		
		3.有关dstCache部分中，各种同步类型的使用
			1.数据不可更改：使用KeyCache类型
			2.数据可更改：不使用缓存机制，但需要dstCache记录比较机制。(缓存没有任何意义)
			3.全表同步：使用RecordCache类型
			
			
####2.5 比较机制
	1. 数据不可改，实时同步。
		将从src获取的所有数据存入RecordCache，断开连接。
		KeyCache比较，没有cache过的进行同步  
	2. 数据不可改，修正同步。  
		将从src获取的所有数据存入RecordCache，断开连接。
		KeyCache比较，没有cache过的进行同步  
	3. 数据可修改。
		将从src获取的所有数据存入RecordCache，断开连接。
		再逐个与dst中的数据进行对比，dst中没有的进行插入。
		主键相同的再进行比较操作。不同的再进行更新操作。
	4. 全表同步。
		将从src获取的所有数据存入RecordCache，断开连接。
		将从dst获取的所有数据存入RecordCache，断开连接。
		以src中数据为基准进行标比较，对主键相同的记录。在进行比较操作。
				
	KeyCache在每次同步前进行过期数据的清理。
	RecordCache在每次同步后进行全cache的清理。
